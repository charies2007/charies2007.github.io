<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://charies2007.github.io</id>
    <title>Star | zzzrx&apos;s Blog</title>
    <updated>2020-02-20T09:39:36.342Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://charies2007.github.io"/>
    <link rel="self" href="https://charies2007.github.io/atom.xml"/>
    <subtitle>仰望星空  是星星还是你？ </subtitle>
    <logo>https://charies2007.github.io/images/avatar.png</logo>
    <icon>https://charies2007.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Star | zzzrx&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[P5750 [NOI1999]钉子和小球]]></title>
        <id>https://charies2007.github.io/post/p5750-noi1999ding-zi-he-xiao-qiu/</id>
        <link href="https://charies2007.github.io/post/p5750-noi1999ding-zi-he-xiao-qiu/">
        </link>
        <updated>2020-02-17T09:50:53.000Z</updated>
        <content type="html"><![CDATA[<p><strong>概率dp经典题</strong></p>
<p>如果当前位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)(i,j)(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>有钉子，那么掉到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i+1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i+1,j+1)(i+1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i+1,j+1)(i+1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(i+1,j+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的概率都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。</p>
<p>而如果没有钉子，那么掉到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(i+2,j+1)(i+2,j+1)(i+2,j+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的概率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>这样转移就行了。</p>
<p>另外注意读入字符要用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">cin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
ll n,m,f[60][60],tot;
char tmp,mp[60][60];
int main()
{
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m),tot=1ll&lt;&lt;n;
	f[1][1]=tot;
	for(int i=1;i&lt;=n;++i)
		for(int j=1;j&lt;=i;++j)
		{
			cin&gt;&gt;tmp;
			if(tmp=='*')f[i+1][j]+=f[i][j]/2,f[i+1][j+1]+=f[i][j]/2;
			else f[i+2][j+1]+=f[i][j];
		}
	if(!f[n+1][m+1]){printf(&quot;0/1&quot;);return 0;}
	while(!(f[n+1][m+1]&amp;1))f[n+1][m+1]&gt;&gt;=1,tot&gt;&gt;=1;
	printf(&quot;%lld/%lld&quot;,f[n+1][m+1],tot);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5479 [BJOI2015]隐身术]]></title>
        <id>https://charies2007.github.io/post/p5479-bjoi2015yin-shen-zhu/</id>
        <link href="https://charies2007.github.io/post/p5479-bjoi2015yin-shen-zhu/">
        </link>
        <updated>2020-02-13T09:43:46.000Z</updated>
        <content type="html"><![CDATA[<p>上次发布了一道<strong>错误</strong>的题解，影响了不少人的刷题，这里我深感抱歉（感觉有点不通顺</p>
<p>这次的题解我已经测试过，100%可以AC，所以正确的问题各位OIer不用担心</p>
<h3 id="solution"><strong>Solution</strong></h3>
<p>考虑枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>的每个后缀<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span><s>（注意后缀是指啥= =）</s>，求后缀<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>中有哪些前缀满足条件。</p>
<p>怎么处理编辑距离呢？<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>很小，直接搜。</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>分别匹配到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>位置，可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">SA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">A</span></span></span></span>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>C</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">LCP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>(x,y)，然后直接跳到下一个不匹配位置。</p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">S_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>≠<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">T_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，那么有三种选择：删掉<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">T_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>→<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">T_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>前插入一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">S_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>→<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">T_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>替换成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">S_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>→<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>的复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">3^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的。</p>
<p>匹配完<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>串后，如果还剩下一些可用编辑距离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">rest</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>，显然此时前缀[<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>−<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">rest</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">rest</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>]都满足条件，差分一下即可。注意这些前缀不要算重（一个位置只能算一次）。</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>n</mi><msup><mn>3</mn><mi>k</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn+n3^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="code"><strong>Code</strong></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
typedef long long LL;
const int N=1e5+7;
 
int na,nb,Now,L,R,sum[N];
char s[N];
struct Suffix_Array
{
    int sa[N],sa2[N],rk[N],tm[N],ht[N],Log[N],st[17][N];
    inline int LCP(int l,int r)
    {
        l=rk[l], r=rk[r]; if(l&gt;r) std::swap(l,r);
        ++l; int k=Log[r-l+1];
        return std::min(st[k][l],st[k][r-(1&lt;&lt;k)+1]);
    }
    void Build(const char *s,const int n)
    {
        int m=27,*x=rk,*y=sa2;
        for(int i=0; i&lt;=m; ++i) tm[i]=0;
        for(int i=1; i&lt;=n; ++i) ++tm[x[i]=s[i]-'A'+1];
        for(int i=1; i&lt;=m; ++i) tm[i]+=tm[i-1];
        for(int i=n; i; --i) sa[tm[x[i]]--]=i;
        for(int k=1,p=0; k&lt;n; k&lt;&lt;=1,m=p,p=0)
        {
            for(int i=n-k+1; i&lt;=n; ++i) y[++p]=i;
            for(int i=1; i&lt;=n; ++i) if(sa[i]&gt;k) y[++p]=sa[i]-k;
 
            for(int i=0; i&lt;=m; ++i) tm[i]=0;
            for(int i=1; i&lt;=n; ++i) ++tm[x[i]];
            for(int i=1; i&lt;=m; ++i) tm[i]+=tm[i-1];
            for(int i=n; i; --i) sa[tm[x[y[i]]]--]=y[i];
 
            std::swap(x,y), x[sa[1]]=p=1;
            for(int i=2; i&lt;=n; ++i)
                x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p;
            if(p&gt;=n) break;
        }
        for(int i=1; i&lt;=n; ++i) rk[sa[i]]=i;
        ht[1]=0;
        for(int i=1,k=0; i&lt;=n; ++i)
        {
            if(rk[i]==1) continue;
            if(k) --k;
            int p=sa[rk[i]-1];
            while(i+k&lt;=n &amp;&amp; p+k&lt;=n &amp;&amp; s[i+k]==s[p+k]) ++k;
            ht[rk[i]]=k;
        }
        st[0][1]=ht[1];
        for(int i=2; i&lt;=n; ++i) Log[i]=Log[i&gt;&gt;1]+1, st[0][i]=ht[i];
        for(int j=1; j&lt;=Log[n]; ++j)
            for(int t=1&lt;&lt;j-1,i=n-t; i; --i)
                st[j][i]=std::min(st[j-1][i],st[j-1][i+t]);
    }
}sa;
 
inline void Upd(int l,int r)
{
    l=std::max(l,Now), r=std::min(r,nb), L=std::min(l,L), R=std::max(r+1,R);
    ++sum[l], --sum[r+1];//注意可行前缀位置的限制（在Now~nb内）
}
void DFS(int x,int y,int rest)
{
    int t=sa.LCP(x,y+na+1);
    x+=t, y+=t;
    if(x&gt;na||y&gt;nb)
    {
        int d=rest-(na-x+1);
        if(d&gt;=0) Upd(y-1-d,y-1+d);
        return;
    }
    if(rest) --rest, DFS(x+1,y,rest), DFS(x,y+1,rest), DFS(x+1,y+1,rest);
}
 
int main()
{
    int K; scanf(&quot;%d%s&quot;,&amp;K,s+1);
    na=strlen(s+1), s[na+1]='[';
    scanf(&quot;%s&quot;,s+na+2), nb=strlen(s+na+2);
    const int n=na+nb+1; sa.Build(s,n);
    int ans=0;
    for(int i=1,delta=std::max(0,na-K); i+delta&lt;=nb; ++i)
    {
        Now=i, L=N, R=0, DFS(1,i,K);
        for(int j=L; j&lt;=R; ++j) ans+=(sum[j]+=sum[j-1])&gt;0;
        for(int j=L; j&lt;=R; ++j) sum[j]=0;
    }
    printf(&quot;%d\n&quot;,ans);
 
    return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P6011 [SCOI2006]动态最值]]></title>
        <id>https://charies2007.github.io/post/p6011-scoi2006dong-tai-zui-zhi/</id>
        <link href="https://charies2007.github.io/post/p6011-scoi2006dong-tai-zui-zhi/">
        </link>
        <updated>2020-02-02T10:37:16.000Z</updated>
        <content type="html"><![CDATA[<p>单点更新，区间查询，适合用线段树来解决。其中注意删除操作的实现。查询区间最大最小值时，注意右子树的标号控制。</p>
<p>更多注释详见代码</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define L(u) (u&lt;&lt;1)
#define R(u) (u&lt;&lt;1|1)
using namespace std;
const int mx=1000001;
struct Tree
{
    int lch,rch,Min,Max,num;
} tree[mx&lt;&lt;2];//Min:区间最小值 Max:区间最大值 num:区间内尚存的，即未被删除的元素数目
int d[mx],m,n,l,r,ans1,ans2;
char s;
void read(int &amp;k)
{
    int f=1;
    char c=getchar();
    while ((c&lt;48||c&gt;57)&amp;&amp;c!='-') c=getchar();
    if (c=='-') f=-1,c=getchar();
    k = 0;
    while (48&lt;=c&amp;&amp;c&lt;=57) k=k*10+c-48,c=getchar();
    k=f*k;
}
void Pushup(int u)
{
    tree[u].Max=max(tree[L(u)].Max,tree[R(u)].Max);
    tree[u].Min=min(tree[L(u)].Min,tree[R(u)].Min);
    tree[u].num=tree[L(u)].num+tree[R(u)].num;
}
void Build(int u,int l,int r)
{//建树。根节点编号是1
    tree[u].lch=l;
    tree[u].rch=r;
    if (l==r)
	{//叶节点
        tree[u].Max=tree[u].Min=d[l];
        tree[u].num=1;
        return ;
    }
    int mid=(l+r)&gt;&gt;1;
    Build(L(u),l,mid);//递归，建左子树
    Build(R(u),mid+1,r);//递归，建右子树
    Pushup(u);//建完两棵子树，向上更新一下
}
void Delete(int u,int num)
{//删除节点的操作实现。这个num是待删元素的标号
    if((tree[u].lch==tree[u].rch))
	{//叶节点。删的就是它
        tree[u].num--;//没有元素了
        tree[u].Min=2147483647;
        tree[u].Max=-2147483648;
        return;
    }
    int n1=tree[L(u)].num;
    if(num&lt;=n1) Delete(L(u),num);//标号≤左子树所含元素个数，则待删元素在左子树上，递归找它
    else Delete(R(u),num-n1);//不是左子树就是右子树啦。注意这里往右子树递归的时候，标号减去左子树所含元素数目
    Pushup(u);//少了元素了，需要更新
}
void Query(int u,int l,int r)
{
    if (l==1&amp;&amp;tree[u].num==r)
	{
        ans1=min(ans1,tree[u].Min);
        ans2=max(ans2,tree[u].Max);
        return ;
    }
    int n1=tree[L(u)].num,n2=tree[R(u)].num;
    if (l&lt;=n1&amp;&amp;r&gt;n1)
	{//待查询区间跨了左右两棵子树
        Query(L(u),l,n1);
        Query(R(u),1,r-n1);
    } else if (l&lt;=n1&amp;&amp;r&lt;=n1) Query(L(u),l,r);//左子树
    else if (l&gt;n1&amp;&amp;r&lt;=n1+n2) Query(R(u),l-n1,r-n1);//右子树
}
int main()
{
    read(n);
    read(m);
    for (int i=1; i&lt;=n; ++i) read(d[i]);
    for (int i=1; i&lt;=4*n; ++i) tree[i].Min=2147483647,tree[i].Max=-2147483648;
    Build(1,1,n);
    while (m--)
	{
        scanf(&quot; %c&quot;,&amp;s);
        if (s=='1')
		{
            scanf(&quot;%d&quot;,&amp;l);
            Delete(1,l);
        }
		else
		{
            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
            ans1=2147483647,ans2=-2147483648;
            Query(1,l,r);
            printf(&quot;%d %d\n&quot;,ans1,ans2);
        }
    }
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[把sublime text 3随身携带]]></title>
        <id>https://charies2007.github.io/post/sublime text 3/</id>
        <link href="https://charies2007.github.io/post/sublime text 3/">
        </link>
        <updated>2019-12-17T11:18:51.000Z</updated>
        <summary type="html"><![CDATA[<p>我们学校一直用<code>dev-cpp</code>，我不能用<code>sublime</code>，<s>不开森</s></p>
<p>为了让<s>广大AFO</s>或刷题的人在<strong>机房</strong>能用上<code>sublime text 3</code></p>
<p><strong>所以，我思考了把Sublime Text 3 便携版装进U盘随身携带的方法</strong></p>
<p><s>在查阅相关教程后，本人现整理出一份基于<code>Sublime Text 3</code>制作便携IDE的方法，供大家参考</s></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="white"><mtext mathvariant="monospace">可以在文末直接下我整理完的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{white}\texttt{可以在文末直接下我整理完的}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text" style="color:white;"><span class="mord texttt cjk_fallback" style="color:white;">可以在文末直接下我整理完的</span></span></span></span></span></span></p>
<hr>
<p><strong>进入正题：</strong></p>
<hr>
<p><em>Step1 下载Sublime Text 3 免安装版</em></p>
<p>去<a href="http://www.sublimetext.com/3">官网</a>查找最新版下载</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/xu1k432z.png" alt="" loading="lazy"></figure>
<p>我们学校是64位的，所以选</p>
<pre><code>Windows 64 bit - also available as a portable version
</code></pre>
<p><s>羡慕不</s></p>
<p>为了考虑<s>兼容性</s>，<strong>大部分</strong>学校的电脑是32位，所以选</p>
<pre><code>Windows - also available as a portable version
</code></pre>
<p>最后，<s>我认为不可能</s>，如果是Linux，选</p>
<pre><code>Linux repos - also available as a 64 bit or 32 bit tarball
</code></pre>
<p><strong>解压以后放在U盘目录下</strong></p>
<hr>
<p><em>Step2 下载MinGW编译器</em></p>
<p>在<a href="https://pan.baidu.com/s/1_yMAlbe6SkO-SX0US1Ow2Q">Link</a>中下载（提取码c5m3）</p>
<p>由于官网下载的链接有时连接不稳定，现在已经有下载好的<code>MinGW32</code>安装包，大家解压后可以直接使用</p>
<p><strong>解压以后放在U盘目录下</strong></p>
<hr>
<p><em>Step3 新建编译系统文件</em></p>
<p>众所周知，Sublime Text 3 初始只有C++的编译系统，且不是在<code>cmd</code>中运行</p>
<p>而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">cin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>c</mi><mi>a</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">scanf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>函数不能使用，所以我们要<strong>新建一个编译系统</strong></p>
<p>因为有两种语言需要编译，要调用两个不同的编译器，分别为<code>gcc</code>和<code>g++</code>，所以有两个<code>.sublime-build</code>（编译系统）文件需要新建</p>
<ul>
<li>C语言</li>
<li>打开<code>Sublime Text 3</code>，选择<code>Tool-Build-System-New Build System...</code>来新建一个编译系统</li>
<li>复制以下代码：</li>
</ul>
<pre><code>{
    &quot;encoding&quot;: &quot;cp936&quot;,
    &quot;working_dir&quot;: &quot;$file_path&quot;,
    &quot;cmd&quot;: &quot;F:/MinGW32/bin/gcc -fexec-charset=GBK -Wall \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,
    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,
    &quot;selector&quot;: &quot;source.C&quot;,
 
    &quot;variants&quot;:
    [
        {   
        &quot;name&quot;: &quot;Run&quot;,
            &quot;shell_cmd&quot;: &quot;F:/MinGW32/bin/gcc -fexec-charset=GBK -Wall \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;${file_path}/${file_base_name}\&quot; &amp; pause\&quot;&quot;
        }
    ]
}
</code></pre>
<ul>
<li>
<p>保存为<code>MY C.sublime-build</code></p>
</li>
<li>
<p>完成！</p>
</li>
<li>
<p>C++语言</p>
</li>
<li>
<p>打开<code>Sublime Text 3</code>，选择<code>Tool-Build-System-New Build System...</code>来新建一个编译系统</p>
</li>
<li>
<p>复制以下代码：</p>
</li>
</ul>
<pre><code>{
    &quot;encoding&quot;: &quot;cp936&quot;,
    &quot;working_dir&quot;: &quot;$file_path&quot;,
    &quot;cmd&quot;: &quot;F:/MinGW32/bin/g++ -fexec-charset=GBK -Wall -std=c++11 \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,
    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,
    &quot;selector&quot;: &quot;source.C++&quot;,
 
    &quot;variants&quot;:
    [
        {
        &quot;name&quot;: &quot;Run&quot;,
            &quot;shell_cmd&quot;: &quot;F:/MinGW32/bin/g++ -fexec-charset=GBK -Wall -std=c++11 \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;${file_path}/${file_base_name}\&quot; &amp; pause\&quot;&quot;
        }
    ]
}
</code></pre>
<ul>
<li>保存为<code>MY C++.sublime-build</code></li>
<li>完成！</li>
</ul>
<p>在这里，需要注意的是，这两个<code>.sublime-build</code>文件的第4行<code>cmd</code>以及第12行<code>shell _ cmd</code>中的<code>F:/MinGW32/bin/gcc</code>和<code>F:/MinGW32/bin/g++</code>需要修改为自己U盘所在的盘符及路径</p>
<p>一般来说，将<code>MinGW</code>放在U盘根目录下，按照我的编译系统，只需要修改盘符</p>
<p>至此，<code>Sublime Text 3</code>已经能够调用U盘上的<code>gcc\g++</code>编译文件了，但是，有些缺少部分文件的电脑在编译时会报错，所以下一步我们来方便地添加这些文件</p>
<p><s>(其实还教了把MinGW编译器随身携带）</s></p>
<hr>
<p><em>Step4 复制缺少的文件</em></p>
<p>在第一次编译时，系统有可能会报错，<strong>缺少部分文件</strong></p>
<p>由于我们是学校机房的电脑，每一次重启都会重置系统，所以一次添加，永久受益是不现实的，所以，我们选择用.bat文件来批量操作，化简这一步骤</p>
<ol>
<li>
<p>统计需要添加的文件</p>
<p>完整地编译、运行一次程序，在<code>MinGW\bin</code>目录下找到所有需要添加的文件</p>
</li>
<li>
<p>将文件名记录下来</p>
<p>也可以将文件统一复制到一个新的文件夹，以后有需要可以继续往里面添加</p>
</li>
<li>
<p>制作一个<code>.bat</code>文件，将需要的文件复制到相应的目录</p>
</li>
</ol>
<ul>
<li>
<p>打开<code>Sublime Text 3</code>，新建一个文件</p>
</li>
<li>
<p>复制粘贴输入以下代码：<s>（因电脑而异，不要照搬）</s></p>
</li>
</ul>
<pre><code>echo Add to compile missing files

copy /y &quot;F:\MinGW32\bin\libgcc_s_dw2-1.dll&quot; &quot;C:\Windows\System32&quot;
copy /y &quot;F:\MinGW32\bin\libgmp-10.dll&quot;      &quot;C:\Windows\System32&quot;
copy /y &quot;F:\MinGW32\bin\libmpc-3.dll&quot;       &quot;C:\Windows\System32&quot;
copy /y &quot;F:\MinGW32\bin\libmpfr-4.dll&quot;      &quot;C:\Windows\System32&quot;
copy /y &quot;F:\MinGW32\bin\zlib1.dll&quot;          &quot;C:\Windows\System32&quot;
copy /y &quot;F:\MinGW32\bin\libstdc++-6.dll&quot;    &quot;C:\Windows\System32&quot;

copy /y &quot;F:\MinGW32\bin\libgcc_s_dw2-1.dll&quot; &quot;C:\Windows\SysWOW64&quot;
copy /y &quot;F:\MinGW32\bin\libgmp-10.dll&quot;      &quot;C:\Windows\SysWOW64&quot;
copy /y &quot;F:\MinGW32\bin\libmpc-3.dll&quot;       &quot;C:\Windows\SysWOW64&quot;
copy /y &quot;F:\MinGW32\bin\libmpfr-4.dll&quot;      &quot;C:\Windows\SysWOW64&quot;
copy /y &quot;F:\MinGW32\bin\zlib1.dll&quot;          &quot;C:\Windows\SysWOW64&quot;
copy /y &quot;F:\MinGW32\bin\libstdc++-6.dll&quot;    &quot;C:\Windows\SysWOW64&quot;

echo Finished
pause
</code></pre>
<ul>
<li>
<p>保存为 添加缺少的文件<code>.bat</code></p>
</li>
<li>
<p>各位可以对照，<strong>按照自己的需求</strong>，添加相应的文件</p>
</li>
</ul>
<p>同样的，需要注意的是，这个添加缺少的文件<code>.bat</code>文件中的的盘符F<strong>需要修改为自己U盘所在的盘符及路径</strong>。<br>
而后面的 <em>C:\Windows\System32</em> 及 <em>C:\Windows\SysWOW64</em> <strong>不需要做修改</strong></p>
<p>需要添加缺少文件时，双击即可运行</p>
<hr>
<h2 id="结束">结束</h2>
<p><s>懒人的</s><a href="https://pan.baidu.com/s/1AEUysnCa1x6O0RAzUfyqmw">Link</a>，<strong>里面有上述所有的文件，只需修改盘符</strong>（提取码eak6）</p>
<p>将它解压缩直接放到U盘根目录下，修改<code>.sublime-build</code>以及添加缺少的文件<code>.bat</code></p>
]]></summary>
        <content type="html"><![CDATA[<p>我们学校一直用<code>dev-cpp</code>，我不能用<code>sublime</code>，<s>不开森</s></p>
<p>为了让<s>广大AFO</s>或刷题的人在<strong>机房</strong>能用上<code>sublime text 3</code></p>
<p><strong>所以，我思考了把Sublime Text 3 便携版装进U盘随身携带的方法</strong></p>
<p><s>在查阅相关教程后，本人现整理出一份基于<code>Sublime Text 3</code>制作便携IDE的方法，供大家参考</s></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="white"><mtext mathvariant="monospace">可以在文末直接下我整理完的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{white}\texttt{可以在文末直接下我整理完的}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text" style="color:white;"><span class="mord texttt cjk_fallback" style="color:white;">可以在文末直接下我整理完的</span></span></span></span></span></span></p>
<hr>
<p><strong>进入正题：</strong></p>
<hr>
<p><em>Step1 下载Sublime Text 3 免安装版</em></p>
<p>去<a href="http://www.sublimetext.com/3">官网</a>查找最新版下载</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/xu1k432z.png" alt="" loading="lazy"></figure>
<p>我们学校是64位的，所以选</p>
<pre><code>Windows 64 bit - also available as a portable version
</code></pre>
<p><s>羡慕不</s></p>
<p>为了考虑<s>兼容性</s>，<strong>大部分</strong>学校的电脑是32位，所以选</p>
<pre><code>Windows - also available as a portable version
</code></pre>
<p>最后，<s>我认为不可能</s>，如果是Linux，选</p>
<pre><code>Linux repos - also available as a 64 bit or 32 bit tarball
</code></pre>
<p><strong>解压以后放在U盘目录下</strong></p>
<hr>
<p><em>Step2 下载MinGW编译器</em></p>
<p>在<a href="https://pan.baidu.com/s/1_yMAlbe6SkO-SX0US1Ow2Q">Link</a>中下载（提取码c5m3）</p>
<p>由于官网下载的链接有时连接不稳定，现在已经有下载好的<code>MinGW32</code>安装包，大家解压后可以直接使用</p>
<p><strong>解压以后放在U盘目录下</strong></p>
<hr>
<p><em>Step3 新建编译系统文件</em></p>
<p>众所周知，Sublime Text 3 初始只有C++的编译系统，且不是在<code>cmd</code>中运行</p>
<p>而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">cin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>c</mi><mi>a</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">scanf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>函数不能使用，所以我们要<strong>新建一个编译系统</strong></p>
<p>因为有两种语言需要编译，要调用两个不同的编译器，分别为<code>gcc</code>和<code>g++</code>，所以有两个<code>.sublime-build</code>（编译系统）文件需要新建</p>
<ul>
<li>C语言</li>
<li>打开<code>Sublime Text 3</code>，选择<code>Tool-Build-System-New Build System...</code>来新建一个编译系统</li>
<li>复制以下代码：</li>
</ul>
<pre><code>{
    &quot;encoding&quot;: &quot;cp936&quot;,
    &quot;working_dir&quot;: &quot;$file_path&quot;,
    &quot;cmd&quot;: &quot;F:/MinGW32/bin/gcc -fexec-charset=GBK -Wall \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,
    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,
    &quot;selector&quot;: &quot;source.C&quot;,
 
    &quot;variants&quot;:
    [
        {   
        &quot;name&quot;: &quot;Run&quot;,
            &quot;shell_cmd&quot;: &quot;F:/MinGW32/bin/gcc -fexec-charset=GBK -Wall \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;${file_path}/${file_base_name}\&quot; &amp; pause\&quot;&quot;
        }
    ]
}
</code></pre>
<ul>
<li>
<p>保存为<code>MY C.sublime-build</code></p>
</li>
<li>
<p>完成！</p>
</li>
<li>
<p>C++语言</p>
</li>
<li>
<p>打开<code>Sublime Text 3</code>，选择<code>Tool-Build-System-New Build System...</code>来新建一个编译系统</p>
</li>
<li>
<p>复制以下代码：</p>
</li>
</ul>
<pre><code>{
    &quot;encoding&quot;: &quot;cp936&quot;,
    &quot;working_dir&quot;: &quot;$file_path&quot;,
    &quot;cmd&quot;: &quot;F:/MinGW32/bin/g++ -fexec-charset=GBK -Wall -std=c++11 \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,
    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,
    &quot;selector&quot;: &quot;source.C++&quot;,
 
    &quot;variants&quot;:
    [
        {
        &quot;name&quot;: &quot;Run&quot;,
            &quot;shell_cmd&quot;: &quot;F:/MinGW32/bin/g++ -fexec-charset=GBK -Wall -std=c++11 \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;${file_path}/${file_base_name}\&quot; &amp; pause\&quot;&quot;
        }
    ]
}
</code></pre>
<ul>
<li>保存为<code>MY C++.sublime-build</code></li>
<li>完成！</li>
</ul>
<p>在这里，需要注意的是，这两个<code>.sublime-build</code>文件的第4行<code>cmd</code>以及第12行<code>shell _ cmd</code>中的<code>F:/MinGW32/bin/gcc</code>和<code>F:/MinGW32/bin/g++</code>需要修改为自己U盘所在的盘符及路径</p>
<p>一般来说，将<code>MinGW</code>放在U盘根目录下，按照我的编译系统，只需要修改盘符</p>
<p>至此，<code>Sublime Text 3</code>已经能够调用U盘上的<code>gcc\g++</code>编译文件了，但是，有些缺少部分文件的电脑在编译时会报错，所以下一步我们来方便地添加这些文件</p>
<p><s>(其实还教了把MinGW编译器随身携带）</s></p>
<hr>
<p><em>Step4 复制缺少的文件</em></p>
<p>在第一次编译时，系统有可能会报错，<strong>缺少部分文件</strong></p>
<p>由于我们是学校机房的电脑，每一次重启都会重置系统，所以一次添加，永久受益是不现实的，所以，我们选择用.bat文件来批量操作，化简这一步骤</p>
<ol>
<li>
<p>统计需要添加的文件</p>
<p>完整地编译、运行一次程序，在<code>MinGW\bin</code>目录下找到所有需要添加的文件</p>
</li>
<li>
<p>将文件名记录下来</p>
<p>也可以将文件统一复制到一个新的文件夹，以后有需要可以继续往里面添加</p>
</li>
<li>
<p>制作一个<code>.bat</code>文件，将需要的文件复制到相应的目录</p>
</li>
</ol>
<ul>
<li>
<p>打开<code>Sublime Text 3</code>，新建一个文件</p>
</li>
<li>
<p>复制粘贴输入以下代码：<s>（因电脑而异，不要照搬）</s></p>
</li>
</ul>
<pre><code>echo Add to compile missing files

copy /y &quot;F:\MinGW32\bin\libgcc_s_dw2-1.dll&quot; &quot;C:\Windows\System32&quot;
copy /y &quot;F:\MinGW32\bin\libgmp-10.dll&quot;      &quot;C:\Windows\System32&quot;
copy /y &quot;F:\MinGW32\bin\libmpc-3.dll&quot;       &quot;C:\Windows\System32&quot;
copy /y &quot;F:\MinGW32\bin\libmpfr-4.dll&quot;      &quot;C:\Windows\System32&quot;
copy /y &quot;F:\MinGW32\bin\zlib1.dll&quot;          &quot;C:\Windows\System32&quot;
copy /y &quot;F:\MinGW32\bin\libstdc++-6.dll&quot;    &quot;C:\Windows\System32&quot;

copy /y &quot;F:\MinGW32\bin\libgcc_s_dw2-1.dll&quot; &quot;C:\Windows\SysWOW64&quot;
copy /y &quot;F:\MinGW32\bin\libgmp-10.dll&quot;      &quot;C:\Windows\SysWOW64&quot;
copy /y &quot;F:\MinGW32\bin\libmpc-3.dll&quot;       &quot;C:\Windows\SysWOW64&quot;
copy /y &quot;F:\MinGW32\bin\libmpfr-4.dll&quot;      &quot;C:\Windows\SysWOW64&quot;
copy /y &quot;F:\MinGW32\bin\zlib1.dll&quot;          &quot;C:\Windows\SysWOW64&quot;
copy /y &quot;F:\MinGW32\bin\libstdc++-6.dll&quot;    &quot;C:\Windows\SysWOW64&quot;

echo Finished
pause
</code></pre>
<ul>
<li>
<p>保存为 添加缺少的文件<code>.bat</code></p>
</li>
<li>
<p>各位可以对照，<strong>按照自己的需求</strong>，添加相应的文件</p>
</li>
</ul>
<p>同样的，需要注意的是，这个添加缺少的文件<code>.bat</code>文件中的的盘符F<strong>需要修改为自己U盘所在的盘符及路径</strong>。<br>
而后面的 <em>C:\Windows\System32</em> 及 <em>C:\Windows\SysWOW64</em> <strong>不需要做修改</strong></p>
<p>需要添加缺少文件时，双击即可运行</p>
<hr>
<h2 id="结束">结束</h2>
<p><s>懒人的</s><a href="https://pan.baidu.com/s/1AEUysnCa1x6O0RAzUfyqmw">Link</a>，<strong>里面有上述所有的文件，只需修改盘符</strong>（提取码eak6）</p>
<p>将它解压缩直接放到U盘根目录下，修改<code>.sublime-build</code>以及添加缺少的文件<code>.bat</code></p>
<!-- more -->
<p>文件中的路径，既可以正常使用</p>
<hr>
<h3 id="如果有不明白或者有更好的方法欢迎在评论区留言以及指正谢谢">如果有不明白，或者有更好的方法，欢迎在评论区留言以及指正！谢谢！</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5567 [SDOI2008]立方体覆盖]]></title>
        <id>https://charies2007.github.io/post/p5567-sdoi2008li-fang-ti-fu-gai/</id>
        <link href="https://charies2007.github.io/post/p5567-sdoi2008li-fang-ti-fu-gai/">
        </link>
        <updated>2019-12-16T06:39:42.000Z</updated>
        <content type="html"><![CDATA[<p>看到题目的描述，就很容易想到扫描线，但是扫描线是二维的，这道题是三维的，怎么办？</p>
<p>我们运用扫描线的思想，将这些立方体分隔成为许多的小立方体（如下图）。我们这样就可以每一次计算小立方体就可以了，每一次我们运用扫描线求出众多矩形的面积并，再乘以横向的长度，就可以求出小体积，再将这些小体积相加，就是答案。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 101
#define inf 1000
int n,cnt,idx,root,ans,tot;
int son[3000&lt;&lt;5][2],times[3000&lt;&lt;5],sum[3000&lt;&lt;5];
struct Surface {int x1,y1,x2,y2,z,kind;}surface[N&lt;&lt;5];
bool cmp1(const Surface &amp;a,const Surface &amp;b) {return a.z&lt;b.z;}
struct Line {int x,y1,y2,kind;}line[N&lt;&lt;1];
bool cmp2(const Line &amp;a,const Line &amp;b) {return a.x&lt;b.x;}
void update(int p,int l,int r)
{(times[p])?sum[p]=r-l+1:sum[p]=sum[son[p][0]]+sum[son[p][1]];}
void change(int &amp;p,int l,int r,int x,int y,int delta)
{
	if(!p) p=++cnt;
	if(x&lt;=l&amp;&amp;r&lt;=y) {times[p]+=delta,update(p,l,r);return;}
	int mid=(l+r)&gt;&gt;1;
	if(x&lt;=mid) change(son[p][0],l,mid,x,y,delta);
	if(y&gt;mid) change(son[p][1],mid+1,r,x,y,delta);update(p,l,r);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
	{
		int a,b,c,d;scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
		surface[++idx].z=c-d,surface[idx].x1=a-d;
		surface[idx].y1=b+d,surface[idx].x2=a+d;
		surface[idx].y2=b-d,surface[idx].kind=1;
		surface[++idx].z=c+d,surface[idx].x1=a-d;
		surface[idx].y1=b+d,surface[idx].x2=a+d;
		surface[idx].y2=b-d,surface[idx].kind=-1;
	}
	sort(surface+1,surface+idx+1,cmp1),surface[idx+1].z=surface[idx].z;
	for(int i=1,tmp=0;i&lt;=idx;tmp=0)
	{
		int area=0;
		while(surface[i].z==surface[i+tmp].z&amp;&amp;i+tmp&lt;=idx) tmp++;
		for(int j=0;j&lt;tmp;j++)
		{
			line[++tot].x=surface[j+i].x1,line[tot].y1=surface[j+i].y2;
			line[tot].y2=surface[j+i].y1-1;
			line[tot].kind=1*surface[i+j].kind;
			line[++tot].x=surface[j+i].x2,line[tot].y1=surface[j+i].y2;
			line[tot].y2=surface[j+i].y1-1;
			line[tot].kind=-1*surface[i+j].kind;
		}sort(line+1,line+tot+1,cmp2);
		for(int j=1,now=0;j&lt;=tot;j+=now,now=0)
		{
			area+=sum[root]*(-line[j-1].x+line[j].x);
			while(line[j+now].x==line[j].x)
				change(root,-inf,inf,line[j+now].y1,line[j+now].y2
					,line[j+now].kind),now++;
		}i+=tmp;
		ans+=area*(surface[i].z-surface[i-1].z);
	}
	printf(&quot;%d&quot;,ans);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5045 [SCOI2003]蜘蛛难题]]></title>
        <id>https://charies2007.github.io/post/p5045-scoi2003zhi-zhu-nan-ti/</id>
        <link href="https://charies2007.github.io/post/p5045-scoi2003zhi-zhu-nan-ti/">
        </link>
        <updated>2019-12-13T05:10:22.000Z</updated>
        <content type="html"><![CDATA[<p>模拟一下， 维护当前水能灌到的最低的位置， 然后使其水位上升1cm1cm1cm。 如果某次水溢出了容器而还没到达蜘蛛的位置就输出−1-1−1。</p>
<p><s>#部分12行</s></p>
<p>可以用万能头</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cctype&gt;
#include &lt;algorithm&gt;
#define R register
#define IN inline
#define W while
#define MX 105
#define gc getchar()
#define ll long long
template &lt;class T&gt;
IN void in(T &amp;x)
{
	x = 0; R char c = gc;
	for (; !isdigit(c); c = gc);
	for (;  isdigit(c); c = gc)
	x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - 48;
}
template &lt;class T&gt; IN T max(T a, T b) {return a &gt; b ? a : b;}
template &lt;class T&gt; IN T min(T a, T b) {return a &lt; b ? a : b;}
int n, m, x, y, cnt;
int head[MX];
bool wat[MX];
struct Pipe {int x, up, down;} pip[MX];
struct Edge {int to, dep, nex;} edge[MX];
IN void add(R int from, R int to, R int dep)
{
	edge[++cnt] = {to, dep, head[from]}, head[from] = cnt;
	edge[++cnt] = {from, dep, head[to]}, head[to] = cnt; 
}
IN int find(R int x)
{
	for (R int i = 1; i &lt;= n; ++i)
	if (pip[i].x == x) return i;
	return 0;
}
int main(void)
{
	in(n); int l, len, p;
	for (R int i = 1; i &lt;= n; ++i)
	in(pip[i].x), in(pip[i].up), in(pip[i].down), pip[i].down += pip[i].up;
	in(m);
	for (R int i = 1; i &lt;= m; ++i)
	{
		in(l), in(p), in(len);
		add(find(l - 1), find(l + len), p);
	}
	in(x), in(y); wat[1] = true; int ans = 0;
	W (233)
	{
		bool nex = true;
		W (nex)
		{
			nex = false;
			for (R int i = 1; i &lt;= n; ++i)
			{
				if (wat[i])
				{
					for (R int j = head[i]; j; j = edge[j].nex)
					{
						if ((!wat[edge[j].to]) &amp;&amp; edge[j].dep &gt;= pip[i].down)
						wat[edge[j].to] = nex = true;
					}
				}
			}
		}
		int mxdp = 0;
		for (R int i = 1; i &lt;= n; ++i) if (wat[i]) mxdp = max(mxdp, pip[i].down);
		if (wat[x] &amp;&amp; mxdp == y) return printf(&quot;%d\n&quot;, ans), 0;
		for (R int i = 1; i &lt;= n; ++i)
		{
			if (wat[i] &amp;&amp; pip[i].down == mxdp)
			{
				if (pip[i].down == pip[i].up) return puts(&quot;-1&quot;), 0;
				++ans, pip[i].down--;
			}
		}
	}
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5025 [SNOI2017]炸弹]]></title>
        <id>https://charies2007.github.io/post/p5025-snoi2017zha-dan/</id>
        <link href="https://charies2007.github.io/post/p5025-snoi2017zha-dan/">
        </link>
        <updated>2019-12-13T04:59:30.000Z</updated>
        <content type="html"><![CDATA[<p>不难发现，在引爆一个炸弹之后发生的一串连锁反应中，只有两种情况：</p>
<p>1.左边（右边）的炸弹依旧引爆左边（右边）的炸弹。</p>
<p>2.左边（右边）的炸弹引爆了原本右边（左边）引爆不了的炸弹。</p>
<p>并且第二种情况可能会在反应中反复很多次。</p>
<p>假设在第二种情况中连缩反应是从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a-&gt;b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>开始的，对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>的答案的计算，只需要从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>递推过来即可。</p>
<p>于是考虑先从左往右递推处理出来每一个点左边的所有能够引爆的炸弹，以及引爆了左边的炸弹之后新增加的炸弹的半径对于右边炸弹的影响。</p>
<p>不难发现第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个炸弹目前的答案就是第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个炸弹最终的答案。</p>
<p>然后从右往左倒着推一遍，处理出每个点右边的范围，这时第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个炸弹的答案是从第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个炸弹推过来的，又因为第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个炸弹的答案是最终的答案，只需要把第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个炸弹的答案合并到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个就好了，这样使得第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个炸弹的答案也是最终的正确答案了。</p>
<p>这样一直递推，一定会使得最后的答案都是正确答案。</p>
<p>考虑时间复杂度的计算，一个点的递推次数取决于它的爆炸范围内有多少个互相不可达的子块。如果有一个点的爆炸范围内有很多的不可达的子块，那么它便会和这些子块合并，不难发现，每个点至多会被用到2次，所以复杂度线性。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;

#define REP(i,a,b) for(int i=a,i##_end_=b;i&lt;=i##_end_;++i)
#define DREP(i,a,b) for(int i=a,i##_end_=b;i&gt;=i##_end_;--i)
typedef long long ll;

using namespace std;

void File(){
    freopen(&quot;bzoj5017.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;bzoj5017.out&quot;,&quot;w&quot;,stdout);
}

template&lt;typename T&gt;void read(T &amp;_){
    T __=0,mul=1; char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')mul=-1;
        ch=getchar();
    }
    while(isdigit(ch))__=(__&lt;&lt;1)+(__&lt;&lt;3)+(ch^'0'),ch=getchar();
    _=__*mul;
}

const int maxn=5e5+10;
const ll mod=1e9+7;
int n,l[maxn],r[maxn];
ll x[maxn],y[maxn],ans;

int main(){
//  File();
    read(n);
    REP(i,1,n)read(x[i]),read(y[i]),l[i]=r[i]=i;
    REP(i,1,n)while(l[i]&gt;1 &amp;&amp; x[i]-x[l[i]-1]&lt;=y[i]){
        y[i]=max(y[i],x[l[i]-1]+y[l[i]-1]-x[i]);
        //cout&lt;&lt;x[l[i]-1]+y[l[i]-1]-x[i]&lt;&lt;&quot; &quot;;
        l[i]=l[l[i]-1];
        y[i]=max(y[i],x[l[i]]+y[l[i]]-x[i]);
        //cout&lt;&lt;x[l[i]]+y[l[i]]-x[i]&lt;&lt;endl;
    }
    DREP(i,n,1)while(r[i]&lt;n &amp;&amp; x[r[i]+1]-x[i]&lt;=y[i]){
        l[i]=min(l[i],l[r[i]+1]);
        //cout&lt;&lt;l[r[i]+1]&lt;&lt;&quot; &quot;;
        r[i]=r[r[i]+1];
        l[i]=min(l[i],l[r[i]]);
        //cout&lt;&lt;l[r[i]]&lt;&lt;endl;
    }
    REP(i,1,n){
        ans=(ans+1ll*i*(r[i]-l[i]+1)%mod)%mod;
        //cout&lt;&lt;l[i]&lt;&lt;&quot; &quot;&lt;&lt;r[i]&lt;&lt;endl;
    }
    printf(&quot;%lld\n&quot;,(ans+mod)%mod);
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5746 [NOI2002]机器人M号]]></title>
        <id>https://charies2007.github.io/post/p5746-noi2002ji-qi-ren-m-hao/</id>
        <link href="https://charies2007.github.io/post/p5746-noi2002ji-qi-ren-m-hao/">
        </link>
        <updated>2019-12-08T08:49:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="解题思路">解题思路</h2>
<p>首先一个机器人m的独立数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">φ(m)φ(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>而老师的数量就是他的因数数量-2，然后把M分解为</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mn>1</mn><mi>e</mi><mn>1</mn><mo>×</mo><mi>p</mi><mn>2</mn><mi>e</mi><mn>2</mn><mo>×</mo><mi>p</mi><mn>3</mn><mi>e</mi><mn>3...</mn><mo>×</mo><mi>p</mi><mi>k</mi><mi>e</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">p1e1×p2e2×p3e3...×pkek</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord">2</span><span class="mord mathdefault">e</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord">3</span><span class="mord mathdefault">e</span><span class="mord">3</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></p>
<p>然后</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">φ(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mn>1</mn><mi>e</mi><mn>1</mn><mo>×</mo><mi>p</mi><mn>2</mn><mi>e</mi><mn>2...</mn><mo>×</mo><mi>p</mi><mi>k</mi><mi>e</mi><mi>k</mi><mo>×</mo><mo>(</mo><mn>1</mn><mi mathvariant="normal">−</mi><mn>1</mn><mi>p</mi><mn>1</mn><mo>)</mo><mo>×</mo><mo>(</mo><mn>1</mn><mi mathvariant="normal">−</mi><mn>1</mn><mi>p</mi><mn>2</mn><mo>)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><mo>(</mo><mn>1</mn><mi mathvariant="normal">−</mi><mn>1</mn><mi>p</mi><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p1e1×p2e2...×pkek×(1−1p1)×(1−1p2)...× (1−1pk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord">2</span><span class="mord mathdefault">e</span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord">1</span><span class="mord mathdefault">p</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord">1</span><span class="mord mathdefault">p</span><span class="mord">2</span><span class="mclose">)</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord">1</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p>
<p>之后</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">φ(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>p</mi><mn>1</mn><mi mathvariant="normal">−</mi><mn>1</mn><mo>)</mo><mi>p</mi><mn>1</mn><mi>e</mi><mn>1</mn><mi mathvariant="normal">−</mi><mn>1</mn><mo>×</mo><mo>(</mo><mi>p</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1</mn><mo>)</mo><mi>p</mi><mn>2</mn><mi>e</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1...</mn><mo>×</mo><mo>(</mo><mi>p</mi><mi>k</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>)</mo><mi>p</mi><mi>k</mi><mi>e</mi><mi>k</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">(p1−1)p1e1−1×(p2−1)p2e2−1...×(pk−1) pkek−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord">1</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">1</span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mord">2</span><span class="mord mathdefault">e</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">−</span><span class="mord">1</span></span></span></span></p>
<p>然后我们就可以发现政客的独立数就是在M的奇质因数中选择偶数个不同的乘起来的欧拉函数，军人就是选奇数个。然后学者就是Ｍ所以的独立数减去政客和军人。</p>
<p>选数我们可以用dp</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i mod 2][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>表示在M因子中只包含前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个的政客的欧拉函数</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i mod 2][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>表示在M因子中只包含前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个的政客的欧拉函数</p>
<p>然后进行动态转移</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mi mathvariant="normal"> </mi><mi>m</mi><mi>o</mi><mi>d</mi><mi mathvariant="normal"> </mi><mn>2</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal"> </mi><mi>m</mi><mi>o</mi><mi>d</mi><mi mathvariant="normal"> </mi><mn>2</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal"> </mi><mi>m</mi><mi>o</mi><mi>d</mi><mi mathvariant="normal"> </mi><mn>2</mn><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo><mi mathvariant="normal">∗</mi><mo>(</mo><mi>p</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f[i mod 2][0]=f[(i+1) mod 2][0]+f[(i+1) mod 2][1]∗(p−1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"> </span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"> </span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"> </span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">∗</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mi mathvariant="normal"> </mi><mi>m</mi><mi>o</mi><mi>d</mi><mi mathvariant="normal"> </mi><mn>2</mn><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal"> </mi><mi>m</mi><mi>o</mi><mi>d</mi><mi mathvariant="normal"> </mi><mn>2</mn><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal"> </mi><mi>m</mi><mi>o</mi><mi>d</mi><mi mathvariant="normal"> </mi><mn>2</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mi mathvariant="normal">∗</mi><mo>(</mo><mi>p</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f[i mod 2][1]=f[(i+1) mod 2][1]+f[(i+1) mod 2][0]∗(p−1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"> </span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"> </span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"> </span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mord">∗</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>最后计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">φ(m)φ(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>减去最后的政客独立数总和和军人独立数总和</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#define mods 10000
using namespace std;
int n,p,e,f[2][2],m=1;
int ksm(int x,int k)//快速幂
{
    int ans=1;
    while (k)
    {
        if (k&amp;1) ans=(ans*x)%mods;
        x=x*x%mods;
        k/=2;
    }
    return ans;
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    scanf(&quot;%d%d&quot;,&amp;p,&amp;e);
    m=m*ksm(p,e)%mods;
    if (p==2) f[1][0]=1;
    else
    {
        f[0][0]=1;
        f[1][0]=(f[0][0]+f[0][1]*(p-1)%mods)%mods;
        f[1][1]=(f[0][1]+f[0][0]*(p-1)%mods)%mods;
    }//初始化
    for (int i=2;i&lt;=n;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;p,&amp;e);
        m=m*ksm(p,e)%mods;
        f[i&amp;1][0]=(f[~-i&amp;1][0]+f[~-i&amp;1][1]*(p-1)%mods)%mods;
        f[i&amp;1][1]=(f[~-i&amp;1][1]+f[~-i&amp;1][0]*(p-1)%mods)%mods;
        //动态转移
    }
    f[n&amp;1][0]--;m=((m-1-f[n&amp;1][0]-f[n&amp;1][1])%mods+mods)%mods;//计算学者
    printf(&quot;%d\n%d\n%d&quot;,f[n&amp;1][0],f[n&amp;1][1],m);
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5747 [NOI2004]曼哈顿]]></title>
        <id>https://charies2007.github.io/post/p5747-noi2004man-ha-dun/</id>
        <link href="https://charies2007.github.io/post/p5747-noi2004man-ha-dun/">
        </link>
        <updated>2019-12-05T11:54:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="解法半枚举-动态规划">解法：半枚举、动态规划。</h2>
<p>首先是观察数据规模发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>很小，于是可以在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>上做文章（这是我一直以为是状压DP的原因。。。）——将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>行的方向枚举出来，这样变量就只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>列的方向了。</p>
<p>以下都是在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>行的方向确定情况进行的讨论。</p>
<p>然后对于一个要求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（x1,y1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（x2,y2）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mord cjk_fallback">）</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">y1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span>关系确定，我们画图可以发现所有的情况都可以等效为一下4种（不包括<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x1=x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>1</mn><mo>=</mo><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">y1=y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span>情况）：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/1a30uub3.png" alt="" loading="lazy"></figure>
<h4 id="将其归纳一下就是">将其归纳一下，就是：</h4>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>行、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span></span></span></span>行符合方向时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>y</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[y1,y2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mclose">]</span></span></span></span>列中要有一个符合方向。</p>
<p>当只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>行符合方向时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>列要符合方向。</p>
<p>当只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span></span></span></span>行符合方向时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">y1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span></span>列要符合方向。</p>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>行、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span></span></span></span>行都不符合方向时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">y1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span>要同时符合方向。</p>
<h4 id="然后讨论x1x2或y1y2的情况">然后讨论x1=x2或y1=y2的情况：</h4>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x1=x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>1</mn><mo>=</mo><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">y1=y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span>时，无论方向都符合。</p>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x1=x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>1</mn><mo>&lt;</mo><mo>&gt;</mo><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">y1&lt;&gt;y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>行要符合方向。</p>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn><mo>&lt;</mo><mo>&gt;</mo><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x1&lt;&gt;x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>1</mn><mo>=</mo><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">y1=y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">y1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span></span>列要符合方向。</p>
<p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span></span></span></span>行的方向建立在半枚举的基础上，所以当不满足方向时，就是无效状态。</p>
<p>排除无效状态后，设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>为1，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>为0，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>列的方向看作长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的数字串，那么上面<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>列的满足条件就都可以等价于区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>中要有一个为0或1。</p>
<p>设为0为0区间，为1为1区间。</p>
<p>问题就变成了求最小代价使所有0、1区间全部得到满足，于是可以用动态规划解决。</p>
<p>DP之前将所有的0、1区间讨论处理出来，分别按l为第一关键字，r为第二关键字排序，作为DP基础。</p>
<p>DP之前还有一个小小的剪枝，就是对于0、1性质相同的区间，如果存在包含关系，则去掉大区间，因为小区间满足大区间也肯定满足，这个优化的效果十分显著。</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">cost[i,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>表示把i列方向变成1的代价，对应的有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">cost[i,0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span>。</p>
<p>动态规划的方程是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i,j,k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>表示前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>列状态确定，且满足了排序后的所有编号在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的0区间与所有编号在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,k-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的1区间的最小代价。</p>
<p>这样通过讨论第i列的状态，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i,j,k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>就可以转移到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">f[i,j1,k1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span></span></span></span>。其中若第i列方向为0，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">j1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">1</span></span></span></span>为第一个左界&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的0区间，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">k1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，转移时要加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">cost[i,0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span>；若第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>列方向为1，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">j1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">1</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">k1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span></span></span></span>第一个左界&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的1区间，转移时要加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">cost[i,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</p>
<p>注意枚举还需要有左边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">j0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">0</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">k0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">0</span></span></span></span>代表第一个包含i的区间，而所有的右边界&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的区间应该在枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>之前全部保证满足。因为没有左边界会从无效状态直接跳到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">j1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">k1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span></span></span></span>，漏掉很多区间限制。</p>
<p>每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">j1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">1</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">k1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span></span></span></span>都可以预处理出来，这样递推取最小值就可以了。边界是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[1,1,1]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，结果是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>+</mo><mn>1</mn><mo>]</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">f[n+1,sum[0]+1,sum[1]+1]+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">+</span></span></span></span>当前行状态的生成代价</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn=111, maxl = 201, inf = 100000000;
int n, m, K, SM, SN[maxn], r[3], rr[3][maxn], ll[3][maxn], costm[maxn][3], costn[maxn][3];
int sm[maxn], sn[maxn], vm[maxn], vn[maxn], f[maxn][maxl][maxl], pp[maxn][maxl][maxl];
char s[maxn], tm[3], tn[3];
bool g[maxn][maxl][maxl];
struct req { int x1, x2, y1, y2; } a[maxn];
struct inter { int l, r; } in[3][maxl]; 

void init()
{
    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
    scanf(&quot;%s&quot;, s);
    for (int i=1; i&lt;=m; ++i) sm[i] = (s[i-1]=='E');
    scanf(&quot;%s&quot;, s);
    for (int i=1; i&lt;=n; ++i) sn[i] = (s[i-1]=='S');
    for (int i=1; i&lt;=m; ++i) 
    {
        scanf(&quot;%d&quot;, vm+i);
        costm[i][sm[i]] = 0, costm[i][1-sm[i]] = vm[i];
    }
    for (int i=1; i&lt;=n; ++i) 
    {
        scanf(&quot;%d&quot;, vn+i);
        costn[i][sn[i]] = 0, costn[i][1-sn[i]] = vn[i];
    }
    scanf(&quot;%d&quot;, &amp;K);
    for (int i=1; i&lt;=K; ++i) 
        scanf(&quot;%d%d%d%d&quot;, &amp;a[i].x1, &amp;a[i].y1, &amp;a[i].x2, &amp;a[i].y2);
    tm[0] = 'W', tm[1] = 'E', tn[0] = 'N', tn[1] = 'S';
}

inline bool cmp(const inter &amp;a,const inter &amp;b) 
{ return a.l&lt;b.l || (a.l==b.l &amp;&amp; a.r&lt;b.r); }

void maintain()
{
    sort(in[0]+1,in[0]+r[0]+1,cmp);
    sort(in[1]+1,in[1]+r[1]+1,cmp);
    for (int q=0; q&lt;2; ++q)
    {
        for (int i=1; i&lt;=n; ++i)
        {
            int j = 1; ll[q][i] = 1;
            for (; j&lt;=r[q]; ++j)
            if (in[q][j].l&gt;i) break;
            else if (in[q][j].r&lt;i) ll[q][i] = j+1;
            rr[q][i] = j; 
        }
    }
}

void add(int p, int L, int R)
{
    if (L&gt;R) swap(L,R);
    for (int i=1; i&lt;=r[p]; ++i)
        if (L&lt;=in[p][i].l &amp;&amp; in[p][i].r&lt;=R) return;
    in[p][++r[p]].l = L, in[p][r[p]].r = R; 
}

bool prepare(int s)
{
    memset(rr, 0 ,sizeof rr);
    memset(ll, 0, sizeof ll);
    r[0] = 0, r[1] = 0;
    for (int i=1; i&lt;=K; ++i)
    {
        int x1 = a[i].x1, y1 = a[i].y1, x2 = a[i].x2, y2 = a[i].y2;
        int p = (x1&lt;x2), q = (y1&lt;y2);
        if (x1!=x2 &amp;&amp; y1!=y2)
        {
            if (((s &gt;&gt; (x1-1)) &amp; 1)==q &amp;&amp; ((s &gt;&gt; (x2-1)) &amp; 1)==q) add(p,y1,y2); 
            else if (((s &gt;&gt; (x1-1)) &amp; 1)==q) add(p,y2,y2);
            else if (((s &gt;&gt; (x2-1)) &amp; 1)==q) add(p,y1,y1);
            else
            {
                int t = 0, fr=min(x1,x2)+1, en=max(x1,x2);
                for (int j=fr; j&lt;en; ++j)
                    if (((s &gt;&gt; (j-1)) &amp; 1)==q) t = 1;
                if (!t) return 0;
                add(p,y1,y1); add(p,y2,y2);
            }
        }
        else if (x1==x2 &amp;&amp; y1!=y2 &amp;&amp; ((s &gt;&gt; (x1-1)) &amp; 1) != q) return 0;
        else if (x1!=x2 &amp;&amp; y1==y2) add(p,y1,y2);
    }
    maintain();
    return 1;
}

int dp()
{
    memset(f, 0x7, sizeof f);
    f[1][1][1] = 0;
    for (int i=1; i&lt;=n; ++i)
    for (int j=ll[0][i]; j&lt;=rr[0][i]; ++j)
    for (int k=ll[1][i]; k&lt;=rr[1][i]; ++k)
    if (f[i][j][k]&lt;inf)
    {
        if (f[i+1][rr[0][i]][k]&gt;f[i][j][k]+costn[i][0])
        {
            f[i+1][rr[0][i]][k] = f[i][j][k]+costn[i][0];
            g[i+1][rr[0][i]][k] = 0;
            pp[i+1][rr[0][i]][k] = j;
        }
        if (f[i+1][j][rr[1][i]]&gt;f[i][j][k]+costn[i][1])
        {
            f[i+1][j][rr[1][i]] = f[i][j][k]+costn[i][1];
            g[i+1][j][rr[1][i]] = 1;
            pp[i+1][j][rr[1][i]] = k;
        }
    }
    return f[n+1][r[0]+1][r[1]+1];
}

void get_SN(int i, int j, int k)
{
    if (i==1) return;
    SN[i-1] = g[i][j][k];
    if (!g[i][j][k]) get_SN(i-1,pp[i][j][k],k);
    else get_SN(i-1,j,pp[i][j][k]);
}

void work()
{
    int tot = (1&lt;&lt;m), ans = inf;
    for (int i=0; i&lt;tot; ++i)
    {
        int t = 0;
        for (int j=1; j&lt;=m; ++j) t += costm[j][(i&gt;&gt;(j-1))&amp;1];
        if (prepare(i))
        {
            t += dp();
            if (t&lt;ans)
            {
                ans = t, SM = i;
                get_SN(n+1,r[0]+1,r[1]+1);
            }
        }
    }
    if (ans&lt;inf)
    {
        printf(&quot;possible\n&quot;);
        printf(&quot;%d\n&quot;, ans);
        while (m--) printf(&quot;%c&quot;, tm[SM &amp; 1]), SM &gt;&gt;= 1;
        printf(&quot;\n&quot;);
        for (int i=1; i&lt;=n; ++i)printf(&quot;%c&quot;, tn[SN[i]]);
        printf(&quot;\n&quot;);
    } else printf(&quot;impossible\n&quot;);
}

int main()
{
    //freopen(&quot;manhattan.in&quot;, &quot;r&quot;, stdin);
    //freopen(&quot;manhattan.out&quot;, &quot;w&quot;, stdout);
    init();
    work();
    return 0;
}
</code></pre>
<p>虽然要枚举所有的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>行状态、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>列、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>m</mi><mo>[</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">um[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，理论极限时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi mathvariant="normal">（</mi><msup><mn>2</mn><mi>m</mi></msup><mi>n</mi><msup><mi>k</mi><mn>2</mn></msup><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">O（2^mnk^2）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span>，但是由于dp之前的排除大区间的优化，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">k^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>实际上是远远达不到的，因为大部分的0、1区间长度都是1，所以不用担心超时的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1141 01迷宫]]></title>
        <id>https://charies2007.github.io/post/p1141-01-mi-gong/</id>
        <link href="https://charies2007.github.io/post/p1141-01-mi-gong/">
        </link>
        <updated>2019-11-29T11:56:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="这是一道非常典型的bfs题">这是一道非常典型的BFS题</h2>
<p>我说实话，这道题和 <strong>填涂颜色</strong> 差不多</p>
<p>都是输入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p><s>所以直接暴搜是最好的</s></p>
<h3 id="上代码">上代码：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
char g[1001][1001];//用char
int det[4][2]={{1,0},{-1,0},{0,-1},{0,1}};//方向
struct Point//个人喜欢用Point
{
	int x,y;
};
Point q[1000101],s;//Point
int res[1001][1001];
bool used[1001][1001];
int ans;
void bfs(Point cur)//bfs（Point）
{
	//memset(used,0,sizeof(used));
	int f=1,e=0;//f必须为1，e必须为0
	used[cur.x][cur.y]=1;
	q[++e]=cur;
	while(f&lt;=e)//满足条件，开始搜索
	{
		Point u=q[f++];//Point
		for(int i=0;i&lt;4;i++)
		{
			Point v;//Point
			v.x=u.x+det[i][0],v.y=u.y+det[i][1];
			if(v.x&lt;0||v.x&gt;=n) continue;//过边界，跳过
			if(v.y&lt;0||v.y&gt;=n) continue;//过边界，跳过
			if(used[v.x][v.y]==1) continue;//重复，跳过
			if(g[u.x][u.y]==g[v.x][v.y]) continue;//同一个点，跳过
			used[v.x][v.y]=1;//第一个点
			ans++;//ans+1
			q[++e]=v;//继续搜索
		}
	}
	for(int i=1;i&lt;=e;i++)
		res[q[i].x][q[i].y]=ans;
}
int main()
{
	memset(res,-1,sizeof(res));//清空res
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=0;i&lt;n;i++)
		scanf(&quot;%s&quot;,g[i]);//scanf省时间
	for(int _m=1;_m&lt;=m;_m++)//已经使用过m，设置个_m作为变量
	{
		scanf(&quot;%d %d&quot;,&amp;s.x,&amp;s.y);//scanf省时间
		s.x--,s.y--;
		if(res[s.x][s.y]==-1)//网格为1
		{
			ans=1;//答案为1
			bfs(s);//开始搜索
		}
		//cout&lt;&lt;res[s.x][s.y]&lt;&lt;endl;
		printf(&quot;%d\n&quot;,res[s.x][s.y]);//printf省时间
	}
	return 0;
}
</code></pre>
<p>代码100%AC</p>
<p>其中有很多优化，比如scanf，printf，自己理解</p>
]]></content>
    </entry>
</feed>